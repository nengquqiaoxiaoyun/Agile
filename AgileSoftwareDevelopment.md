## 第七章 什么是敏捷设计

（敏捷）开发人员知道要做什么，是因为：

1. 遵循敏捷**实践**去发现问题
2. 应用设计**原则**去诊断问题
3. 应用适当的**设计模式**去解决问题

软件开发的这三个方面间的相互作用就是设计

### 结论

什么是敏捷设计呢？敏捷设计是一个过程，不是一个事件。它是一个持续性的应用**原则，模式以及实践**来改进软件的结构和可读性的过程。它致力于保持系统设计在任何时间都尽可能得简单、干净以及富有表现力

请记住，敏捷开发人员不会对一个庞大的预先设计应用那些原则和模式。相反，这些原则和模式被应用在一次次的迭代中，力图使代码以及代码所表达的设计保持干净

## 第八章 单一职责原则（Single Responsibility Principle）

如果一个类承担的职责过多，就等于把这些职责耦合在了一起。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏

为何要把多个职责分离到单独的类中呢？因为每一个职责都是变化的曲线（意为需求时刻在变化）。当需求变化时，该变化就会反映为类的职责的变化。如果一个类承担了多余一个职责，那么引起它变化的原因就会有多个

### 脆弱性

对系统的改动会导致系统中和改动的地方在概念上无关的许多地方出现问题

## 第九章 开放—封闭原则（Open Closed Principle）

遵循开放封闭原则设计出的模块具有两个主要特征：

1. 对于拓展是开发的
2. 对于修改是封闭的

开发人员应该仅仅对程序中呈现出频繁变化的那些部分作出抽象。拒绝不成熟的抽象和抽象本身一样重要

## 第十章 Liskov 替换原则（Liskov Substitution Principle）

解释：继承必须确保超类所拥有的性质在子类中仍然成立，通俗来讲就是：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法

里氏替换原则是实现开闭原则的重要方式之一

**正是因为子类的可替换性才使得使用基类类型的模块在无需修改的情况下就可以扩展**

继承时不应该只关注”IS A“（”IS A“过于宽泛不能作为子类型的定义）关系，更重要的是行为方式（理解为具体的行为），行为方式是可以进行合理假设的，是客户程序所依赖的

若继承违背了LSP，可以考虑用提取公共部分的方法代替继承（继承自公共部分）

## 第十一章 依赖倒置原则（Dependence Inversion Principle）

依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合

高层模块若依赖于低层模块，那么对低层模块的改动将会直接影响到高层模块

> 所有结构良好的面向对象结构都具有清晰的层次定义，每个层次通过一个定义良好的、受控的接口向外提供了一组内聚的服务

对于DIP有个简单的启发式规则：”依赖于抽象“。也就是说，程序中所有的依赖关系都应该终止与抽象类或者接口（参数应该是接口）

根据该启发规则可知：

- 任何变量都不应该持有一个指向具体的指针或引用
  - 正例：private Father father;
  - 反例：private Child child;
- 任何类都不应该从具体类派生
  - 正例：private Father father = new Child();
  - 反例：private Child child = new Child();
- 任何方法都不应该覆盖基类中已经实现了的方法（尽量遵循LSP）

通过以上规则，我们可以推出应该为所有的类创建父类（接口，抽象类，父类）

**依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性**

当然，每个程序中都有会违反该规则的情况（视具体情况而定，有时需要覆盖基类的方法等）

**我们应用中所编写的大多是具体类都是不稳定的，我们不想直接依赖于这些不稳定的具体类。通过把他们隐藏在抽象接口的后面，可以隔离他们的不稳定性**

## 第十二章 接口隔离原则（Interface Segregation Principle）

ISP要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法

当一个客户程序要求一个臃肿的类（接口 fat class）进行一个改动时，会影响到所有其他的客户程序

## 第十三章 COMMAND模式

### COMMAND模式

命令模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开（将调用操作的对象（调用者）和知道如何实现该操作（实现者）的对象解耦）

命令模式可以被轻易的扩展和删除（增加删除类）而不会影响到其他类

#### 结构

![image-20201225111457905](assets/image-20201225111457905.png)

某调用者存储具体的命令对象，该调用者调用命令对象的方法来提交一个请求。（如果该请求是可以撤销的，具体的命令对象在执行方法之前存储当前状态用意取消该命令）具体的命令对象调用接收者对象的方法来执行该请求

调用者调用命令对象来执行请求（不关心具体命令），命令对象执行接收者的操作

## 第十四章 TEMPLATE METHOD模式和STRATEGY模式：继承与委托

模板方法模式和策略模式所解决的问题是类似的，而且常常可以互换。不过，模板方法模式使用继承来解决问题，而策略模式使用的则是委托（委托指的是在A类中以各种方式利用B类（关联、依赖），完成类的功能）

ps：优先使用对象组合而不是类继承，所以我们减少了对继承的使用，常常使用组合或者委托来代替它

### TEMPLATE METHOD模式

模板方法模式：定义一个算法的骨架（步骤是明确的），将具体的实现交由子类实现。简答来讲就是一次性实现一个算法的不变部分，将可变行为交给子类实现

#### 结构

![image-20201228104217465](assets/image-20201228104217465.png)

父类可提供钩子方法（判断逻辑），使用钩子方法可以使子类控制父类的行为

### STRATEGY模式

策略模式：定义一系列算法，将算法封装起来，并且使得他们可以互换

策略模式的重心不是如何实现算法，而是如何组织这些算法，从而让程序结构更加灵活，具有更好的维护性和扩展性

大部分时候策略模式可以和模板方法模式互换

#### 结构